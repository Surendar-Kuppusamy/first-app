import { Injectable, Inject } from '@angular/core';
import { LOCKER_DRIVER_TYPES } from './DriverTypes';
import { LockerConfig } from './LockerConfig';
var Locker = (function () {
    function Locker(driverTypes, lockerConfig) {
        this.driverTypes = driverTypes;
        this.lockerConfig = lockerConfig;
        this.setNamespace();
        this.setSeparator();
        this.setDriverFallback();
    }
    Locker.prototype.setNamespace = function (namespace) {
        if (namespace === void 0) { namespace = this.lockerConfig.driverNamespace; }
        this.namespace = namespace;
    };
    Locker.prototype.setSeparator = function (separator) {
        if (separator === void 0) { separator = this.lockerConfig.namespaceSeparator; }
        this.separator = separator;
    };
    Locker.prototype.setDriverFallback = function (driverFallback) {
        if (driverFallback === void 0) { driverFallback = this.lockerConfig.driverFallback; }
        this.driverFallback = driverFallback;
    };
    Locker.prototype.set = function (type, key, data, config) {
        this._getDriver(type).set(this._makeKey(key), data, config);
    };
    Locker.prototype.get = function (type, key) {
        return this._getDriver(type).get(this._makeKey(key));
    };
    Locker.prototype.has = function (type, key) {
        return this._getDriver(type).has(this._makeKey(key));
    };
    Locker.prototype.remove = function (type, key) {
        this._getDriver(type).remove(this._makeKey(key));
    };
    Locker.prototype.key = function (type, index) {
        return this._decodeKey(this._getDriver(type).key(index));
    };
    Locker.prototype.clear = function (type) {
        this._getDriver(type).clear();
    };
    Locker.prototype._makeKey = function (key) {
        return this.namespace ? "" + this.namespace + this.separator + key : key;
    };
    Locker.prototype._decodeKey = function (key) {
        if (this.namespace)
            return key.slice(this.namespace.length + this.separator.length);
        else
            return key;
    };
    Locker.prototype._getDriver = function (type) {
        var askedDriver = this._getDriverType(type);
        if (askedDriver && askedDriver.storage.isSupported())
            return askedDriver.storage;
        else
            return this._getFallbackDriverType().storage;
    };
    Locker.prototype._getDriverType = function (type) {
        return this.driverTypes.find(function (driverType) { return driverType.type === type; });
    };
    Locker.prototype._getFallbackDriverType = function () {
        var _this = this;
        if (Array.isArray(this.driverFallback)) {
            return this.driverFallback
                .map(function (type) { return _this._getDriverType(type); })
                .find(function (driverType) { return driverType.storage.isSupported(); }) || this._getDriverType("memory" /* MEMORY */);
        }
        else if (this.driverFallback) {
            var driverType = this._getDriverType(this.driverFallback);
            return driverType.storage.isSupported() ? driverType : this._getDriverType("memory" /* MEMORY */);
        }
        else {
            return this._getDriverType("memory" /* MEMORY */);
        }
    };
    Locker.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    Locker.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: Inject, args: [LOCKER_DRIVER_TYPES,] },] },
        { type: LockerConfig, },
    ]; };
    return Locker;
}());
export { Locker };
//# sourceMappingURL=Locker.js.map